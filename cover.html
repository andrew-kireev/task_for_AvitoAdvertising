
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">tast_for_AvitoAdvertising/internal/handler/advertsrepository_mock.go (70.8%)</option>
				
				<option value="file1">tast_for_AvitoAdvertising/internal/handler/handler.go (48.6%)</option>
				
				<option value="file2">tast_for_AvitoAdvertising/store/adversrepository.go (68.6%)</option>
				
				<option value="file3">tast_for_AvitoAdvertising/store/config.go (0.0%)</option>
				
				<option value="file4">tast_for_AvitoAdvertising/store/store.go (33.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: adversrepository.go

// Package mock_store is a generated GoMock package.
package handler

import (
        gomock "github.com/golang/mock/gomock"
        reflect "reflect"
        model "tast_for_AvitoAdvertising/internal/model"
)

// MockAdvertRepositoryInterface is a mock of AdvertRepositoryInterface interface
type MockAdvertRepositoryInterface struct {
        ctrl     *gomock.Controller
        recorder *MockAdvertRepositoryInterfaceMockRecorder
}

// MockAdvertRepositoryInterfaceMockRecorder is the mock recorder for MockAdvertRepositoryInterface
type MockAdvertRepositoryInterfaceMockRecorder struct {
        mock *MockAdvertRepositoryInterface
}

// NewMockAdvertRepositoryInterface creates a new mock instance
func NewMockAdvertRepositoryInterface(ctrl *gomock.Controller) *MockAdvertRepositoryInterface <span class="cov8" title="1">{
        mock := &amp;MockAdvertRepositoryInterface{ctrl: ctrl}
        mock.recorder = &amp;MockAdvertRepositoryInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAdvertRepositoryInterface) EXPECT() *MockAdvertRepositoryInterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreateAdvert mocks base method
func (m *MockAdvertRepositoryInterface) CreateAdvert(advert *model.Advert) (*model.Advert, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateAdvert", advert)
        ret1, _ := ret[1].(error)
        return advert, ret1
}</span>

// CreateAdvert indicates an expected call of CreateAdvert
func (mr *MockAdvertRepositoryInterfaceMockRecorder) CreateAdvert(advert interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAdvert", reflect.TypeOf((*MockAdvertRepositoryInterface)(nil).CreateAdvert), advert)
}</span>

// GetAdvertById mocks base method
func (m *MockAdvertRepositoryInterface) GetAdvertById(id int, optionalFields string) (*model.Advert, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAdvertById", id, optionalFields)
        ret0, _ := ret[0].(*model.Advert)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAdvertById indicates an expected call of GetAdvertById
func (mr *MockAdvertRepositoryInterfaceMockRecorder) GetAdvertById(id, optionalFields interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAdvertById", reflect.TypeOf((*MockAdvertRepositoryInterface)(nil).GetAdvertById), id, optionalFields)
}</span>

// GetAllAdverts mocks base method
func (m *MockAdvertRepositoryInterface) GetAllAdverts(sort string) ([]model.Advert, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllAdverts", sort)
        ret0, _ := ret[0].([]model.Advert)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllAdverts indicates an expected call of GetAllAdverts
func (mr *MockAdvertRepositoryInterfaceMockRecorder) GetAllAdverts(sort interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllAdverts", reflect.TypeOf((*MockAdvertRepositoryInterface)(nil).GetAllAdverts), sort)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package handler

import (
        "encoding/json"
        "github.com/gorilla/mux"
        "github.com/sirupsen/logrus"
        "net/http"
        "strconv"
        "tast_for_AvitoAdvertising/internal/model"
        "tast_for_AvitoAdvertising/store"
)

const pageSize = 10

type Handler struct {
        router *mux.Router
        store  *store.Store
        logger *logrus.Logger
}

type CreationResponse struct {
        ResultCode string `json:"result"`
        AdvertId   int    `json:"id"`
}

func (handler *Handler) ConfigHandler(store *store.Store, logger *logrus.Logger) <span class="cov8" title="1">{
        handler.router = mux.NewRouter()
        handler.router.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Write([]byte("hello"))
        }</span>)
        <span class="cov8" title="1">handler.router.HandleFunc("/advert/create", handler.HandleAdvertCreation)
        handler.router.HandleFunc("/advert/get/{id:[0-9]+}", handler.HandlerGetAdvert)
        handler.router.HandleFunc("/advert/list/{page:[0-9]+}", handler.HandlerGetAllAdverts)
        handler.store = store
        handler.logger = logger</span>
}

func (handler *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        handler.router.ServeHTTP(w, r)
}</span>

func (handler *Handler) HandleAdvertCreation(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        handler.logger.Info("HandleAdvertCreation")
        advert := &amp;model.Advert{}
        advert.Name = r.FormValue("name")
        advert.Description = r.FormValue("description")
        advert.PhotoLinks = r.FormValue("links")
        advert.Price, _ = strconv.Atoi(r.FormValue("price"))

        advert, err := handler.store.Adverts().CreateAdvert(advert)
        handler.logger.Info(advert)

        if err != nil </span><span class="cov0" title="0">{
                handler.logger.Errorf("error in CreateAdvert: %v", err)
                response := CreatFailedResp()
                w.Write(response)
                return
        }</span>
        <span class="cov8" title="1">response := CreationResponse{}
        response.AdvertId = advert.AdvertId
        response.ResultCode = "success"
        resp, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                handler.logger.Errorf("error in maishaling json: %v", err)
                response := CreatFailedResp()
                w.Write(response)
                return
        }</span>
        <span class="cov8" title="1">w.Write(resp)</span>
}

func (handler *Handler) HandlerGetAdvert(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        handler.logger.Info("HandlerGetAdvert")
        vars := mux.Vars(r)
        id, _ := strconv.Atoi(vars["id"])
        optionalFields := r.FormValue("fields")
        advert, err := handler.store.Adverts().GetAdvertById(id, optionalFields)
        if err != nil </span><span class="cov0" title="0">{
                handler.logger.Errorf("error in GetAdvertById: %v", err)
                w.Write([]byte("{}"))
                return
        }</span>
        <span class="cov8" title="1">response, err := json.Marshal(advert)
        if err != nil </span><span class="cov0" title="0">{
                handler.logger.Errorf("error in marshaling json: %v", err)
                w.Write([]byte("{}"))
                return
        }</span>

        <span class="cov8" title="1">w.Write(response)</span>
}

func (handler *Handler) HandlerGetAllAdverts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        handler.logger.Info("HandlerGetAllAdverts")
        vars := mux.Vars(r)
        page, _ := strconv.Atoi(vars["page"])
        sort := r.URL.Query().Get("sort")

        adverts, err := handler.store.Adverts().GetAllAdverts(sort)
        if err != nil </span><span class="cov0" title="0">{
                handler.logger.Errorf("error in GetAllAdverts: %v", err)
                w.Write([]byte("[]"))
                return
        }</span>

        <span class="cov0" title="0">var pageEnd = (page + 1) * pageSize
        var pageBegin = page * pageSize
        if pageEnd &gt; len(adverts) </span><span class="cov0" title="0">{
                pageEnd = len(adverts)
        }</span>
        <span class="cov0" title="0">if pageBegin &gt; len(adverts) </span><span class="cov0" title="0">{
                pageBegin = len(adverts)
        }</span>

        <span class="cov0" title="0">adverts = adverts[pageBegin:pageEnd]
        response, err := json.Marshal(adverts)
        if err != nil </span><span class="cov0" title="0">{
                handler.logger.Errorf("error in marshaling json: %v", err)
                w.Write([]byte("[]"))
                return
        }</span>
        <span class="cov0" title="0">w.Write(response)</span>
}

func CreatFailedResp() []byte <span class="cov8" title="1">{
        response := CreationResponse{}
        response.AdvertId = -1
        response.ResultCode = "failed"
        resp, _ := json.Marshal(response)
        return resp
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package store

import (
        "database/sql"
        "strings"
        "tast_for_AvitoAdvertising/internal/model"
)

type AdvertRepositoryInterface interface {
        CreateAdvert(advert *model.Advert) (*model.Advert, error)
        GetAdvertById(id int, optionalFields string) (*model.Advert, error)
        GetAllAdverts(sort string) ([]model.Advert, error)
}

type AdvertRepository struct {
        store *Store
}

func (rep *AdvertRepository) CreateAdvert(advert *model.Advert) (*model.Advert, error) <span class="cov0" title="0">{
        if err := advert.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := advert.ValidateLinks(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := rep.store.db.QueryRow(
                "INSERT INTO adverts (name, description, photo_links, price) values ($1, $2, $3, $4) RETURNING id",
                advert.Name, advert.Description, advert.PhotoLinks, advert.Price,
        ).Scan(&amp;advert.AdvertId); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return advert, nil</span>
}

func (rep *AdvertRepository) GetAdvertById(id int, optionalFields string) (*model.Advert, error) <span class="cov8" title="1">{
        advert := &amp;model.Advert{}
        if err := rep.store.db.QueryRow(
                "SELECT * FROM adverts where id = $1",
                id).Scan(&amp;advert.AdvertId, &amp;advert.Name, &amp;advert.Description, &amp;advert.PhotoLinks,
                &amp;advert.Price, &amp;advert.CreationDate); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !strings.Contains(optionalFields, "description") </span><span class="cov8" title="1">{
                advert.Description = ""
        }</span>
        <span class="cov8" title="1">if !strings.Contains(optionalFields, "links") </span><span class="cov8" title="1">{
                advert.PhotoLinks = ""
        }</span>
        <span class="cov8" title="1">return advert, nil</span>
}

func (rep *AdvertRepository) GetAllAdverts(sort string) ([]model.Advert, error) <span class="cov8" title="1">{
        var rows *sql.Rows
        var err error
        if sort == "date" </span><span class="cov0" title="0">{
                rows, err = rep.store.db.Query("SELECT * FROM adverts order by creation_date")
        }</span> else<span class="cov8" title="1"> if sort == "-date" </span><span class="cov0" title="0">{
                rows, err = rep.store.db.Query("SELECT * FROM adverts order by creation_date desc")
        }</span> else<span class="cov8" title="1"> if sort == "price" </span><span class="cov8" title="1">{
                rows, err = rep.store.db.Query("SELECT * FROM adverts order by price")
        }</span> else<span class="cov8" title="1"> if sort == "-price" </span><span class="cov0" title="0">{
                rows, err = rep.store.db.Query("SELECT * FROM adverts order by price desc")
        }</span> else<span class="cov8" title="1"> {
                rows, err = rep.store.db.Query("SELECT * FROM adverts")
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer rows.Close()
        adverts := make([]model.Advert, 0)

        for rows.Next() </span><span class="cov8" title="1">{
                newAdvert := model.Advert{}
                err = rows.Scan(&amp;newAdvert.AdvertId, &amp;newAdvert.Name, &amp;newAdvert.Description, &amp;newAdvert.PhotoLinks,
                        &amp;newAdvert.Price, &amp;newAdvert.CreationDate)
                adverts = append(adverts, newAdvert)
        }</span>
        <span class="cov8" title="1">return adverts, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package store

type Config struct {
        DataBaseUrl string `toml:"database_url"`
}

func NewConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                DataBaseUrl: "",
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package store

import (
        "database/sql"
        _ "github.com/lib/pq"
)

type Store struct {
        db        *sql.DB
        AdvertRep AdvertRepositoryInterface
        config    *Config
}

func NewStore(config *Config) *Store <span class="cov0" title="0">{
        return &amp;Store{
                config: config,
        }
}</span>

func (store *Store) Open() error <span class="cov0" title="0">{
        db, err := sql.Open("postgres", store.config.DataBaseUrl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">store.db = db

        return nil</span>
}

func (store *Store) Close() {<span class="cov0" title="0">

}</span>

func (store *Store) Adverts() AdvertRepositoryInterface <span class="cov8" title="1">{
        if store.AdvertRep != nil </span><span class="cov8" title="1">{
                return store.AdvertRep
        }</span>

        <span class="cov8" title="1">store.AdvertRep = &amp;AdvertRepository{
                store: store,
        }
        return store.AdvertRep</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
